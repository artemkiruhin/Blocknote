@page "/edit/{id:guid}"
@using Blocknote.Core.Models.Dtos
@using Blocknote.Core.Models.Enums
@using Blocknote.Core.Services.Base
@using Blocknote.Core.Services.Entity
@using Blocknote.Core.Services.Jwt
@using Blocknote.Core.Services.Sharing
@using Blocknote.Core.Services.Extensions;
@using System.Text
@using Microsoft.AspNetCore.Builder
@using Microsoft.JSInterop
@using System.Diagnostics
@using iTextSharp.text
@using iTextSharp.text.pdf
@using DocumentFormat.OpenXml.Packaging
@using DocumentFormat.OpenXml.Wordprocessing
@using Markdig

@inject INoteService NoteService
@inject IJwtService JwtService
@inject NavigationManager NavigationManager
@inject ISharingService SharingService

<div class="modal">
    <div class="modal-content">
        <h2>
            <!-- Use Lucide Note or Edit icon here -->
            @(Id.HasValue ? "Редактировать заметку" : "Создать новую заметку")
        </h2>
        
        <EditForm Model="@CurrentNote" OnValidSubmit="OnSave">
            <div>
                <input type="text" class="modal-input" placeholder="Заголовок заметки" 
                       @bind="LocalTitle" @bind:event="oninput" />
                <ValidationMessage For="@(() => LocalTitle)" class="validation-message" />
            </div>
            
            <div>
                <input type="text" class="modal-input" placeholder="Подзаголовок (необязательно)" 
                       @bind="LocalSubtitle" @bind:event="oninput" />
            </div>
            
            <div>
                <textarea class="modal-textarea" placeholder="Содержание заметки (необязательно)" 
                          @bind="LocalContent" @bind:event="oninput"></textarea>
            </div>
            
            <div class="modal-buttons">
                <button type="button" class="modal-cancel" @onclick="OnClose">
                    <X /> Отмена
                </button>
                <button type="submit" class="modal-save" disabled="@(!IsFormValid)">
                    <Save /> @(Id.HasValue ? "Обновить" : "Сохранить")
                </button>
                @if (Id.HasValue)
                {
                    <button type="button" class="modal-share" @onclick="OnShare">
                        <Share2 /> Поделиться
                    </button>
                    <button type="button" class="modal-delete" @onclick="ShowDeleteConfirmation">
                        <Trash2 /> Удалить
                    </button>
                    <button type="button" class="modal-export" @onclick="ExportToMarkdown">
                        <FileText /> MD
                    </button>
                    <button type="button" class="modal-export" @onclick="ExportToHTML">
                        <Code /> HTML
                    </button>
                }
            </div>
        </EditForm>
    </div>
</div>

@if (ShowDeleteConfirmationModal)
{
    <div class="modal-overlay">
        <div class="modal-confirmation">
            <p>Вы уверены, что хотите удалить эту заметку?</p>
            <div class="modal-buttons">
                <button class="modal-cancel" @onclick="CancelDelete">Отмена</button>
                <button class="modal-delete" @onclick="OnDelete">Удалить</button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public Guid? Id { get; set; }

    private NoteDto CurrentNote { get; set; } = new NoteDto();
    private string LocalTitle { get; set; } = string.Empty;
    private string LocalSubtitle { get; set; } = string.Empty;
    private string LocalContent { get; set; } = string.Empty;
    private string? ErrorMessage { get; set; }
    private bool ShowDeleteConfirmationModal { get; set; } = false;
    private MarkdownPipeline _markdownPipeline;

    private bool IsFormValid => !string.IsNullOrWhiteSpace(LocalTitle);

    protected override async Task OnInitializedAsync()
    {
        _markdownPipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .Build();

        if (Id.HasValue)
        {
            await LoadNote();
        }
    }

    private async Task LoadNote()
    {
        try
        {
            var token = await SecureStorage.Default.GetAsync("jwt");
            if (string.IsNullOrEmpty(token))
            {
                NavigationManager.NavigateTo("auth");
                return;
            }

            var userId = JwtService.GetUserId(token);
            if (userId == Guid.Empty)
            {
                ErrorMessage = "Ошибка авторизации.";
                return;
            }

            CurrentNote = await NoteService.GetInfoAsync(userId, Id.Value);
            if (CurrentNote != null)
            {
                LocalTitle = CurrentNote.Title;
                LocalSubtitle = CurrentNote.Subtitle;
                LocalContent = CurrentNote.Content;
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Не удалось загрузить заметку: {ex.Message}";
        }
    }

    private void OnShare()
    {
        if (Id.HasValue)
        {
            var noteId = Id.Value.ToString("D");
            NavigationManager.NavigateTo($"/sharing/create/{noteId}");
        }
    }

    private async Task OnSave()
    {
        try
        {
            var token = await SecureStorage.Default.GetAsync("jwt");
            if (string.IsNullOrEmpty(token))
            {
                NavigationManager.NavigateTo("auth");
                return;
            }

            var userId = JwtService.GetUserId(token);
            if (userId == Guid.Empty)
            {
                ErrorMessage = "Ошибка авторизации.";
                return;
            }

            bool result;
            if (Id.HasValue)
            {
                result = await NoteService.EditAsync(userId, Id.Value, LocalTitle, LocalSubtitle, LocalContent);
            }
            else
            {
                result = await NoteService.CreateAsync(LocalTitle, LocalSubtitle, LocalContent, userId);
            }

            if (result)
            {
                NavigationManager.NavigateTo("/");
            }
            else
            {
                ErrorMessage = "Не удалось сохранить изменения.";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Произошла ошибка: {ex.Message}";
        }
    }

    private void ShowDeleteConfirmation() => ShowDeleteConfirmationModal = true;

    private void CancelDelete() => ShowDeleteConfirmationModal = false;

    private async Task OnDelete()
    {
        if (!Id.HasValue) return;

        try
        {
            var token = await SecureStorage.Default.GetAsync("jwt");
            if (string.IsNullOrEmpty(token))
            {
                NavigationManager.NavigateTo("auth");
                return;
            }

            var userId = JwtService.GetUserId(token);
            if (userId == Guid.Empty)
            {
                ErrorMessage = "Ошибка авторизации.";
                return;
            }

            bool result = await NoteService.DeleteAsync(userId, Id.Value);

            if (result)
            {
                NavigationManager.NavigateTo("/");
            }
            else
            {
                ErrorMessage = "Не удалось удалить заметку.";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Произошла ошибка: {ex.Message}";
        }
    }

    private void OnClose()
    {
        NavigationManager.NavigateTo("/");
    }



    private async Task ExportToPdf()
    {
        try
        {
            var pdfBytes = TextFormatter.FormatPdf(LocalTitle, LocalSubtitle, LocalContent);
            if (pdfBytes != null && pdfBytes.Length > 0)
            {
                var fileName = $"{LocalTitle}.pdf";
                var filePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), fileName);

                await File.WriteAllBytesAsync(filePath, pdfBytes);

                await Application.Current.MainPage.DisplayAlert("Успешно", $"Файл сохранён в {filePath}", "OK");
                Process.Start(new ProcessStartInfo { FileName = Path.GetDirectoryName(filePath), UseShellExecute = true });
            }
            else
            {
                await Application.Current.MainPage.DisplayAlert("Ошибка", "Не удалось создать PDF", "OK");
            }
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert("Ошибка", ex.Message, "OK");
        }
    }


    private async Task ExportToHTML()
    {
        try
        {
            var html = TextFormatter.FormatHtml(LocalTitle, LocalSubtitle, LocalContent);
            await SaveFile(html, LocalTitle, "html");
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert("Ошибка", ex.Message, "OK");
        }
    }


    private async Task ExportToMarkdown()
    {
        var markdown = TextFormatter.FormatMarkdown(LocalTitle, LocalSubtitle, LocalContent);
        await SaveFile(markdown, LocalTitle, "md");
    }

    private async Task SaveFile(string content, string fileName, string fileExtension)
    {
        try
        {
            var documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            var exportPath = Path.Combine(documentsPath, "Blocknote", "Exports");
            Directory.CreateDirectory(exportPath);

            var filePath = Path.Combine(exportPath, $"{fileName}.{fileExtension}");
            await File.WriteAllTextAsync(filePath, content);
            await Application.Current.MainPage.DisplayAlert("Успешно", $"Файл сохранён в {filePath}", "OK");

            Process.Start(new ProcessStartInfo { FileName = exportPath, UseShellExecute = true });
        }
        catch (Exception ex)
        {
            await Application.Current.MainPage.DisplayAlert("Ошибка", ex.Message, "OK");
        }
    }

    protected override void OnParametersSet()
    {
        if (!Id.HasValue)
        {
            CurrentNote = new NoteDto();
            LocalTitle = string.Empty;
            LocalSubtitle = string.Empty;
            LocalContent = string.Empty;
        }
    }
}